# -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil; -*-
# vim:expandtab:shiftwidth=4:tabstop=4:

%include "common.conf"

# used to be rbh 2.5 "purge" policy in TMPFS mode
define_policy cleanup {
    scope { type != directory }
    status_manager = none;
    default_action = common.unlink;
    default_lru_sort_attr = last_access;
}

######## file classes ##########
FileClass scratch_files {
    definition { type == file and tree == "/mnt/lustre/scratch" }
    report = yes; # (default)
}

FileClass scratch_tmp_files {
    definition { type == file and tree == "/mnt/lustre/scratch/tmp" }
    report = yes; # (default)
}

FileClass foo_files {
    definition { type == file and name == "*.foo" }
    report = yes; # (default)
}

FileClass bar_files {
    definition { type == file and name == "*.bar" }
    report = yes; # (default)
}

FileClass root_files {
    definition { type == file and owner == root }
    report = yes; # (default)
}

FileClass default_files {
    definition { type == file and tree != "/mnt/lustre/scratch" and
        name != "*.foo" and name != "*.bar" and owner != root }
    report = yes; # (default)
}

#### Deleting old unused files in scratch#######

cleanup_parameters {
    nb_threads = 4;

    # max_action_volume  = 10TB;
    # max_action_count   = 380000;
    # db_result_size_max = 300000;
    lru_sort_attr      = none;

    # suspend policy run if action error rate > 50% (after 100 errors)
    suspend_error_pct  = 50%;
    suspend_error_min  = 100;
    report_actions     = yes;
    queue_size         = 4096;

    report_interval    = 10min;
    # action_timeout     = 2h;


    # check_actions_on_startup= no
    # check_actions_interval  = 0 # (disabled)
    # recheck_ignored_entries = no
    # pre_maintenance_window  = 0 # (disabled)
    # maint_min_apply_delay   = 30min

}

cleanup_rules {
    ignore { owner == tutu or owner == babar }
    ignore_fileclass = foo_files;
    ignore_fileclass = bar_files;

    rule scratch_cleanup {
        target_fileclass = scratch_files;
        condition { last_access > 60d and last_mod > 60d }
    }

    rule scratch_tmp_cleanup {
        target_fileclass = scratch_tmp_files;
        target_fileclass = root_files;
        condition { last_access > 3d and last_mod > 3d }
    }

    rule default {
        condition {last_mod > 10}
    }
}

cleanup_trigger {
    trigger_on = periodic;
    check_interval = 24h;
}

