# -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil; -*-
# vim:expandtab:shiftwidth=4:tabstop=4:

General {
	fs_path = /mnt/lustre;
	fs_type = lustre;
}

#### policy definitions ####

# include template policy definitions for Lustre/HSM
%include "includes/lhsm.inc"
# include template policy definitions for legacy TMPFS flavor
%include "includes/tmpfs.inc"
# include template policy definitions for removing directories
%include "includes/rmdir.inc"
# include template for alerts
%include "includes/alerts.inc"
# include template for checksuming
%include "includes/check.inc"

#### fileclass definitions ####

FileClass even_files {
    definition { type == file and name == "*[02468]" }
    # only for policy matching, not to display in reports
    report = no;
}

FileClass odd_files {
    definition { type == file and name == "*[13579]" }
    lhsm_archive_action_params { archive_id = 2; }
    report = no;
}

# fileclasses to display in reports (can still be used in policies)
FileClass empty_files {
    definition { type == file and size == 0 }
    # report = yes (default)
}
FileClass small_files {
    definition { type == file and size > 0 and size <= 16MB }
    # report = yes (default)
}
FileClass std_files {
    definition { type == file and size > 16MB and size <= 1GB }
}
FileClass big_files {
    definition { type == file and size > 1GB }
}

FileClass largedir {
    definition { type == directory and dircount > 10000 }
}

FileClass f1 {
    definition { type == file and name == "file.1" }
}

FileClass f2 {
    definition { type == file and name == "file.2" }
}

#### Common Lustre/HSM parameters ####

lhsm_config {
    # used for 'undelete': command to change the fid of an entry in archive
    rebind_cmd = "/usr/sbin/lhsmtool_posix --hsm_root=/tmp/backend --archive {archive_id} --rebind {oldfid} {newfid} {fsroot}";
}

#### Lustre/HSM archive configuration ####


lhsm_archive_parameters {
    nb_threads = 8;
## archive 1000 files max at once
#    max_action_count = 1000;
#    max_action_volume = 1TB;

    # suspend policy run if action error rate > 50% (after 100 errors)
    suspend_error_pct = 50%;
    suspend_error_min= 100;

    # overrides policy default action
    action = cmd("lfs hsm_archive --archive {archive_id} /mnt/lustre/.lustre/fid/{fid}");

    # default action parameters
    action_params {
        archive_id = 1;
    }
}

lhsm_archive_rules {
    ignore_fileclass = empty_files;

    rule archive_small {
        target_fileclass = small_files;
        condition { last_mod >= 30min }

        # overrides policy action
        action = cmd("lfs hsm_archive {fullpath}");
        action_params { archive_id = 2; }
    }

    rule archive_std {
        target_fileclass = std_files;
        target_fileclass = big_files;
        action_params { archive_id = 1; }
        condition { last_mod >= 30min }
    }

    # fallback rule
    rule default {
        action_params { archive_id = 3; }
        condition { last_mod >= 30min }
    }
}

# run every 5 min
lhsm_archive_trigger {
    trigger_on = periodic;
    check_interval = 5min;
}

#### Lustre/HSM release configuration ####

lhsm_release_rules {
    ignore_fileclass = empty_files;

    # keep small files on disk as long as possible
    rule release_small {
        target_fileclass = small_files;
        condition { last_access > 1y }
    }

    rule release_std {
        target_fileclass = std_files;
        target_fileclass = big_files;
        condition { last_access > 1d }
    }

    # fallback rule
    rule default {
        condition { last_access > 6h }
    }
}

# run 'lhsm_release' on full OSTs
lhsm_release_trigger {
    trigger_on = ost_usage;
    high_threshold_pct = 85%;
    low_threshold_pct  = 80%;
    check_interval     = 5min;
}

lhsm_release_parameters {
    nb_threads = 8;
## purge 1000 files max at once
#    max_action_count = 1000;
#    max_action_volume = 1TB;

    # suspend policy run if action error rate > 50% (after 100 errors)
    suspend_error_pct = 50%;
    suspend_error_min= 100;
}


#### Deleting old unused files #######

cleanup_rules {
    rule default {
        condition { last_access > 30d }
    }
}

# clean when inode count > 100M
cleanup_trigger {
    trigger_on = global_usage;
    high_threshold_cnt = 100M;
    low_threshold_cnt  = 100M;
    check_interval     = 5min;
}

### Alerts specification 
alert_rules {

    # don't check entries more frequently than daily
    ignore { last_check < 1d }
    # don't check entries while they are modified
    ignore { last_mod < 1h }

    rule raise_alert {
        ## List all fileclasses that would raise alerts HERE:
        target_fileclass = f1;
        target_fileclass = f2;
        target_fileclass = largedir;

        # customize alert title:
        action_params { title = "entry matches '{fileclass}' ({rule})"; }

        # apply to all matching fileclasses in the policy scope
        condition = true;
    }

    # clear alert status
    rule default {
        action = none;
        action_params { alert = clear; }
        # apply to all entries that don't match 'raise_alert'
        condition = true;
    }
}

# trigger alert check hourly
alert_trigger {
    trigger_on = periodic;
    check_interval = 1h;
}


########### checksum rules ############

fileclass never_checked {
    # never checked or no successful check
    definition { checksum.last_success == 0 }
    # don't display this fileclass in --classinfo reports.
    report = no;
}

checksum_rules {
    ignore { last_check < 7d }
    ignore { last_mod < 1d }

    rule initial_check {
        target_fileclass = never_checked;
        condition { last_mod > 1d }
    }

    rule default {
       condition { last_mod > 1d and last_check > 7d }
    }
}

# start checksum hourly
checksum_trigger {
    trigger_on = periodic;
    check_interval = 1h;
}

############# rmdir rules ############

rmdir_empty_parameters {
    lru_sort_attr = none;
}

rmdir_empty_trigger {
    trigger_on = periodic;
    check_interval = 1h;
}

rmdir_empty_rules {
    ignore { depth < 4 }

    rule default {
        condition { last_mod > 15d }
    }
}

########### end of policy rules ############


# ChangeLog Reader configuration
# Parameters for processing MDT changelogs :
ChangeLog {
    # 1 MDT block for each MDT :
    MDT {
        # name of the first MDT
        mdt_name  = "MDT0000" ;

        # id of the persistent changelog reader
        # as returned by "lctl changelog_register" command
        reader_id = "cl1" ;
    }
    polling_interval = 1s;
}

Log {
    # Log verbosity level
    # Possible values are: CRIT, MAJOR, EVENT, VERB, DEBUG, FULL
    debug_level = EVENT;

    # Log file
    log_file = "/var/log/robinhood/lustre.log";

    # File for reporting purge events
    report_file = "/var/log/robinhood/lustre_actions.log";

    # set alert_file, alert_mail or both depending on the alert method you wish
    alert_file = "/var/log/robinhood/lustre_alerts.log";
    alert_show_attrs = yes;
}

ListManager {
	MySQL {
		server = "localhost";
		db = "robinhood_lustre";
        user = "robinhood";
		# password or password_file are mandatory
		password = "robinhood";
        engine = innodb;
	}
}
